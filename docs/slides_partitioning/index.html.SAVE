<!DOCTYPE html>
	<html class="sl-root decks export offline loaded">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>Partitioning</title>

		<meta name="description" content="Partitioning">

		<link rel="stylesheet" type="text/css" href="lib/offline-v2.css">



	</head>
	<body class="reveal-viewport theme-font-montserrat theme-color-white-blue">
		<div class="reveal">
			<div class="slides">
				<section data-background-image="partitioning/910cbb85b74afc7213eea7e505f8ccda.png" data-background-size="contain" data-id="5090cf9df06ad9c601c13d5893ba7303"></section><section data-background-image="partitioning/092cfd25d5ce1f918ab6422fa55a1d2b.png" data-background-size="contain" data-id="781617983218d0b50c184959854a5640"></section><section data-background-image="partitioning/3f0d19a8806de11e7d35c4ed4f82816c.png" data-background-size="contain" data-id="23ee6854a8f077e3b54d86f29300df81"></section><section data-background-image="partitioning/79de9d5fc7282f6982b2137941249bbf.png" data-background-size="contain" data-id="7bd8286e2f30ffa17c8a9910070c28ca"></section><section data-background-image="partitioning/69588adf26cac5a4aba4921b8993a070.png" data-background-size="contain" data-id="0a930d00bff69d514ab14679e4bc094f"></section><section data-background-image="partitioning/dee4149cf19a27fe4c3c8ec92ed82d00.png" data-background-size="contain" data-id="08e7bce412486f213dc39890860ac52a"></section><section data-background-image="partitioning/fdfd01e5f9a19375dcac95d820d301e7.png" data-background-size="contain" data-id="1b08edea30f8d143bc413f8d754ea8a0"></section><section data-background-image="partitioning/9305074e6f8f04dc00bdc05f6afbc703.png" data-background-size="contain" data-id="b79b1c33bc46de8fb504c442ead92495"></section><section data-background-image="partitioning/213422643d92346bb67504d3ee5b8643.png" data-background-size="contain" data-id="8b9fe94fd9d33a6eee431fc35d724463"></section><section data-background-image="partitioning/09e153ef553888812ac4db30818be764.png" data-background-size="contain" data-id="bfef62482034c0d3692bc0b10edab4e9"></section><section data-background-image="partitioning/0826274ac7a9d4073a7833ebc1c05948.png" data-background-size="contain" data-id="42a0b8d6156a45a4c0af43375bc51e67"></section><section data-background-image="partitioning/1b03ffa6e2a0a6580368c9311d0d905c.png" data-background-size="contain" data-id="b6a830a6b551bb0315ec7d11c1431e0c"></section><section data-background-image="partitioning/d7e39f6444a3e5f776044dcd409e1469.png" data-background-size="contain" data-id="b2e1de81567e3c72b8e27330a61fb3b3"></section><section data-background-image="partitioning/95ba340956bbdece2ea78255480ea5c7.png" data-background-size="contain" data-id="c397a811ea216227760476ec93562aed"></section><section data-background-image="partitioning/9359f680403e50fcf0ed9835bee98af3.png" data-background-size="contain" data-id="ab00cd603e40739af5f420e4ab20e556"></section><section data-background-image="partitioning/8e38a57be83ea06a68feaceae0c4a10d.png" data-background-size="contain" data-id="c0b39ad8d18a267ec1d1ace24a786d5a"></section><section data-background-image="partitioning/a697cfcba70c9566c33d0540fc7fbc50.png" data-background-size="contain" data-id="d60733f53484d9df01c1642ce9e6341e"></section><section data-background-image="partitioning/f434354d0983c4cbe39505dc48022ab1.png" data-background-size="contain" data-id="737fa5472be359524305d1fde2d3ac5a"></section><section data-background-image="partitioning/630891de9fdf77054e7850ea8c6ee1de.png" data-background-size="contain" data-id="95721df72a4f95511e9c922ab336b4ec"></section>
			</div>
		</div>

		<script>
			var SLConfig = {"deck": {"id":1578803,"slug":"partitioning","title":"Partitioning","description":"Partitioning","width":960,"height":700,"visibility":"self","published_at":null,"sanitize_messages":null,"thumbnail_url":"https://s3.amazonaws.com/media-p.slid.es/thumbnails/071404f15c0bc5f9a74255532b7a0795/thumb.jpg?1565805316","view_count":0,"user":{"id":1047136,"username":"lwalstad-pivotal","name":null,"description":null,"thumbnail_url":"https://www.gravatar.com/avatar/8e257aa94b14c5462bb5651052f8e1c3?s=140\u0026d=https%3A%2F%2Fstatic.slid.es%2Fimages%2Fdefault-profile-picture.png","paid":true,"pro":false,"lite":true,"team_id":null,"settings":{"id":3098317,"present_controls":true,"present_upsizing":true,"present_pointer":false,"present_notes":true,"default_deck_tag_id":null}},"background_transition":"none","transition":"slide","theme_id":null,"theme_font":"montserrat","theme_color":"white-blue","auto_slide_interval":0,"comments_enabled":true,"forking_enabled":false,"rolling_links":false,"center":false,"shuffle":false,"should_loop":false,"share_notes":true,"slide_number":true,"slide_count":19,"rtl":false,"version":2,"collaborative":null,"deck_user_editor_limit":1,"data_updated_at":1566256723659,"font_typekit":null,"font_google":null,"time_limit":null,"upsizing_enabled":true,"notes":{"5090cf9df06ad9c601c13d5893ba7303":"","781617983218d0b50c184959854a5640":"","23ee6854a8f077e3b54d86f29300df81":"Table partitioning is used to logically divide large tables to improve query performance and facilitate data warehouse maintenance tasks.\n- All structure of the parent table propagates to its children through table inheritance.\nIt is important to keep in mind that parent tables contain no data; all data is stored at the child table level.\nIf you create an index on the table, you will be implicitly creating an index on each of the child tables (the partitions).\nIt is also possible to create an index on the individual partitions.\n\n","7bd8286e2f30ffa17c8a9910070c28ca":"While Greenplum is not afraid of full table scans, it is a good idea to partition your table to help Greenplum process the table as efficiently as possible. However, your business rules should dictate if and how you partition tables.\nThe following are some of the reasons for considering table partition as part of the design:\nProvide more efficiency in querying against a subset of large volumes of transactional detail data as well as to manage this data more effectively. Businesses have recognized the analytic value of detailed transactions and are storing larger and larger volumes of this data.\nIncrease query efficiency by avoiding full table scans.\nWithout the overhead and maintenance costs of an index for date.\nAs the retention volume of detailed transactions increases, the percent of transactions that the “average” query requires for execution decreases.\nAllow the instantaneous dropping of old data and the simple addition of newer data that may be queried more often. One of the practical uses of partition tables is partition swapping or partition exchanging. This type of practice allows you to load data to a table and replace an existing table with the same data plus the updated information with little impact to the original table.\nSupport a rolling n periods methodology for transactional data. \nYou can have default partitions that act as a catchall. This allows you to insert rows without having to worry about a partition. Later, you can alter the table to split the partition with the values that you want to go to the partitioned table.\n","0a930d00bff69d514ab14679e4bc094f":"Table partitioning may be used to improve query performance by scanning only the relevant data needed to satisfy a given query. Table partitioning does not affect the physical distribution of data. GPDB supports both range partitioning or list partitioning.  Range partitioning partitions the data based on a numerical range, for example by date, while list partitioning partitions the data based on a list of values, for example location (store, city, state, region). Partitioning using a combination of range partitioning and list partitioning is also supported.  Table partitioning is implemented using table inheritance and constraints. Check constraints limit the data a table can contain based on some defining criteria. These constraints are also used at runtime to determine which child tables to scan in order to satisfy a given query.\n","08e7bce412486f213dc39890860ac52a":"Let’s begin by considering how table partitioning, combined with a couple of other GPDB storage features, provides a powerful Information Lifecycle Management, or “ILM”, solution.  This example shows a large, partitioned, fact table, tracking transactions back to January 2000.  The current month is “live”, and its data is stored in a row-oriented partition, which is defined on a tablespace which links to an SSD-based filespace.  Queries against this partition are extremely reponsive, and may include INSERT, UPDATE, and DELETE, in addition to SELECT.  The previous month’s data, along with data going back on year, is housed within Append-Optimized, columnar partitions, defined within a tablespace tied to SAS disks.  This portion of the data is optimized for the type of reports the organization needs to run against data for the past year.  Older, “deep history” data, is stored on an adjacent Hadoop cluster, within a partition defined as an external table, using the “gphdfs” protocol.  When a query’s date range includes endpoints spanning any of these time periods, the relevant data is automatically scanned.\n\nThis is the power available through table partitioning.\n\n","1b08edea30f8d143bc413f8d754ea8a0":"Table partitioning:\nAddresses the problem of supporting very large tables, such as fact tables, by allowing you to divide them into smaller and more manageable pieces. \nCan improve query performance by scanning only the relevant data needed to satisfy a given query. Data is eliminated either during the planning phase or at runtime. This helps to reduce the number of rows returned for joins and further actions.\nCan be used to facilitate database maintenance tasks such as rolling old data out of the data warehouse or speeding up the update of indexes.\nWorks using table inheritance and constraints.\nTable inheritance creates a persistent relationship between a child table and its parent table(s), so that all of the schema information from the parent table propagates to its children. \nCHECK constraints limit the data a table can contain based on some defining criteria. These constraints are also used at runtime to determine which tables to scan in order to satisfy a given query.\nIn Greenplum Database, partitioned tables are distributed across the segments as is any non-partitioned table. Partitioning is the method of logically dividing big tables to improve query performance and maintenance. It distinct from the DISTRIBUTED BY clause.\n","b79b1c33bc46de8fb504c442ead92495":"Greenplum Database supports:\nRange partitioning, where the data used for partitioning is based on a numerical range, such as date or price.\nList partitioning, where data used for partitioning is based on a list of values, such as a region.\nA combination of range and list partitioning.\n","8b9fe94fd9d33a6eee431fc35d724463":"There are several reasons why you would partition your data:\nLarge fact table – Large fact tables are good candidates for table partitioning. If you have billions of rows in a table, you will see performance benefits from breaking that data up into smaller chunks. For smaller tables, avoid partitioning.\nUnsatisfactory performance – As with any performance tuning initiative, a table should be partitioned only if queries against that table are producing slower response times than desired.\nIdentifiable access patterns – Examine the WHERE clauses of your query workload and look for table columns that are consistently used to access data. For example, if most of your queries look up records by date, then date range based partitioning design might be beneficial.\nMaintaining rolling data – as discussed earlier, partitioning provides great ILM benefits.\nDividing data into equal parts – Choose a partitioning criteria that will divide your data as evenly as possible.  For example, by dividing a large table into 10 partitions of equal size, you should see a 10x speedup for queres having predicates which restrict them to scanning a single partition.\n","bfef62482034c0d3692bc0b10edab4e9":"A table can only be partitioned at creation time using the CREATE TABLE command.\nThe first step in partitioning a table is to decide on the partition design (date range, numeric range, or list of values) and choose the column on which to partition the table.\n\nYou can partition a table using:\nA date range\nA numeric range\nA list\n","42a0b8d6156a45a4c0af43375bc51e67":"You can define a date range or a numeric range for a partitioned table:\nA date range uses a single date or timestamp column as the partition key column.\nWhen date partitioning a table, consider partitioning by the most granular level you are interested in. For example, partition by day and have 365 daily partitions, rather than partitioning by year, then subpartitioning by month, then subpartitioning by day.\nYou can have Greenplum Database automatically generate partitions by giving a START value, an END value, and an EVERY clause that defines the partition increment value.\nBy default, START values are always inclusive and END values are always exclusive.\nNote: You can declare and name each partition individually.\n","b6a830a6b551bb0315ec7d11c1431e0c":"A numeric range uses a single numeric data type column as the partition key column\n\nCaveat: avoid using DEFAULT PARTITION, because it is always scanned, and in certain cases can contain far more data than expected.\n","b2e1de81567e3c72b8e27330a61fb3b3":"You can define a date range or a numeric range for a partitioned table:\nA date range uses a single date or timestamp column as the partition key column.\nWhen date partitioning a table, consider partitioning by the most granular level you are interested in. For example, partition by day and have 365 daily partitions, rather than partitioning by year, then subpartitioning by month, then subpartitioning by day.\nYou can have Greenplum Database automatically generate partitions by giving a START value, an END value, and an EVERY clause that defines the partition increment value.\nBy default, START values are always inclusive and END values are always exclusive.\nNote: You can declare and name each partition individually.\n","c397a811ea216227760476ec93562aed":"It is not possible to partition a table that has already been created. Tables can only be partitioned at CREATE TABLE time.\nTo partition an existing table, you must:\nRecreate the table as a partitioned table.\nReload the data into the newly partitioned table.\nDrop the original table and rename the partitioned table to the original name.\nGrant any table permissions to the new table that were granted on the original table.\n","ab00cd603e40739af5f420e4ab20e556":"","c0b39ad8d18a267ec1d1ace24a786d5a":"","d60733f53484d9df01c1642ce9e6341e":"Some partition information can be obtained by using the \\d+ PSQL meta-command. All child tables are displayed by their names. \n\nYou can obtain additional information from the pg_partitions view.\n\nThe pg_partition_columns view displays the column used for partitioning.\n\n","737fa5472be359524305d1fde2d3ac5a":"With partitioned table structure, top-level parent tables are empty. Data is routed to the bottom-level child table partitions. COPY or INSERT automatically loads to the correct partition. Best practice for loading data into partitioned tables is to create an intermediate staging table, load it, and then exchange it into your partition table. You can exchange partitions only at the lowest level of your partition hierarchy. Rows that cannot be mapped to a child table partition are rejected and the load fails. To avoid unmapped rows being rejected at load time, define your partition hierarchy with a DEFAULT partition. Any rows that do not match a partition’s CHECK constraints load into the DEFAULT partition.\nThe DEFAULT partition is always scanned and can slow down the overall scan time. \n\n","95721df72a4f95511e9c922ab336b4ec":"Use for very large tables, such as fact tables, to improve query performance. For smaller tables the administrative overhead of maintaining the partitions will outweigh any performance benefits you might see. The primary goal of table partitioning is to eliminate scanning partitions that contain data that is not needed to satisfy a query.  Consider table partitioning on large tables that can be divided into somewhat equal parts based on a defining criteria and the defining criteria is used in query predicates.  If the query access pattern (SELECT….WHERE) does not match the partitioning definition the benefit of partition elimination is not achieved. \nWhen defining partitioning criteria it is important to not have overlapping ranges if using range partitioning and to ensure list values are unique if using list partitioning.  \n\n\n"}}};


			// Use local fonts
			SLConfig.fonts_url = 'lib/fonts/';
		</script>

		<script src="lib/reveal.min.js"></script>
		<script src="lib/offline.js"></script>

		<!-- Initialize the presentation -->
		<script>
			Reveal.initialize({
				width: 960,
				height: 700,
				margin: 0.05,
				

				hash: true,
				controls: true,
				progress: true,
				mouseWheel: false,
				showNotes: true,
				slideNumber: true,

				autoSlide: 0,
				autoSlideStoppable: true,

				center: false,
				shuffle: false,
				loop: false,
				rtl: false,

				transition: "slide",
				backgroundTransition: "none",

				highlight: {
					escapeHTML: false
				},

				dependencies: [
					{ src: 'lib/reveal-plugins/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/reveal-plugins/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/reveal-plugins/highlight/highlight.js' },
					{ src: 'lib/reveal-plugins/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'lib/reveal-plugins/zoom/zoom.js', async: true }
				]
			});
		</script>

		

	</body>
</html>
